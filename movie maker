redfile = 
greenfile = 

time = input_file_green[0,0]  #start at t=0 or t=1 for CellProfiler or Matlab
redtimeslist = redfile[:,0].tolist()  #list format of the frame numbers (as many of each frame # as there are cells in it)
greentimeslist = greenfile[:,0].tolist()  #list format of the frame numbers (as many of each frame # as there are cells in it)
        
while time < redfile[(redfile.shape[0] - 1),0] + 1:  # while time <= last timeframe (assumes red and green are same lengths in terms of time)

  redfirsttime = redtimeslist.index(time)  #index for first instance of frame number
  redlasttime = len(redtimeslist) - redtimeslist[::-1].index(time) - 1 #index for last instance of frame number
  redtimearray = np.arange(redfirsttime,(redlasttime + 1))  #list of indices for all red cells in frame 'time'
    
  greenfirsttime = greentimeslist.index(time)  #index for first instance of frame number
  greenlasttime = len(greentimeslist) - greentimeslist[::-1].index(time) - 1 #index for last instance of frame number
  greentimearray = np.arange(greenfirsttime,(greenlasttime + 1))  #list of indices for all green cells in frame 'time'

  cell_positions_green = greenfile[greenfirsttime:(greenlasttime + 1),5:] * microns_per_pixel
  cell_positions_red = redfile[redfirsttime:(redlasttime + 1),5:] * microns_per_pixel

  #find the total number of cells that are neighbours in frame 'time':
  total_cell_neighbours_green = greenfile[greenfirsttime:(greenlasttime + 1),2] + greenfile[greenfirsttime:(greenlasttime + 1),2:3] + greenfile[greenfirsttime:(greenlasttime + 1),2:4]
  total_cell_neighbours_red = redfile[redfirsttime:(redlasttime + 1),2] + redfile[redfirsttime:(redlasttime + 1),3] + redfile[redfirsttime:(redlasttime + 1),4]
  total_cell_neighbours_all = np.concatenate((total_cell_neighbours_green, total_cell_neighbours_red), axis=0)
  
                         
# Clustering
    min_pts = int(math.ceil(np.mean(total_cell_neighbours_all))) + 1

    db = DBSCAN(eps=radius, min_samples=min_pts).fit(np.transpose(cell_positions))

    num_colors = 12

    labels = db.labels_

    label_i = 0
    while label_i < len(db.labels_):
        label = labels[label_i]
        if label == -1:
            label = 0
        else:
            label = label % num_colors + 1
        labels[label_i] = label
        label_i += 1

# Generate graph image
scale = 0.025

redf = '#FF9090'
greenf = '#75CF90'
redl = '#FF3535'
greenl = '#019A2F'

g = Graph(name='cellgraph' + info, format='png', engine='neato')

g.attr('node', pin='true', shape='circle', width='0.5', fixedsize='true', style='filled', penwidth='3',
       colorscheme='set312', fontname='courier', fontsize='10.0')
g.attr('edge', fontsize='10.0', penwidth='2', fontname='courier')

i = 0
while i < data.shape[0]:
    x, y = cell_positions[0, i], cell_positions[1, i]
    position = str(x * scale) + ',' + str(y * scale * -1)

    if options.cluster:
        note = '\nC' + str(db.labels_[i])
        if labels[i] == 0:
            fill = 'white'
        else:
            fill = str(labels[i])
    else:
        note = ''
        fill = cell_type(i, 'hex')

    g.node(cell_name(i), label=cell_name(i) + note, pos=position, color=cell_type(i, 'hex'),
           fillcolor=fill)

    for ni in cell_neighbours[i]:
        if cell_type(i) == cell_type(ni):
            lcolor = cell_type(i, 'hex')
        else:
            lcolor = 'black'

        label = ''
        if printdist:
            label = str(round(distance, 2))

        g.edge(cell_name(i), cell_name(ni), color=lcolor, label=label)
    i += 1

g.render(directory + '/cellgraph' + info + '.gv')                                             

time += 1
